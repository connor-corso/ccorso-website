
[
    {
        "id":"2",
        "title": "Dockerizing a Python app",
        "sections":
        [
            {
                "title":"Setting up a new folder",
                "text": "Pop into a bash shell in the new folder, then you will want to run the commands below, make sure to install the pip packages that you want",
                "code":
                {   
                    "code":"cd /path/to/python app \npython3 -m venv .venv\nsource .venv/bin/activate\npython3 -m pip install **MODULES YOU WANT**\npython3 -m pip freeze > requirements.txt",
                    "language":"bash"
                }
            },
            {
                "title":"Creating the Dockerfile",
                "text": "Make sure to pay attention to the versions of the base containers and the CMD, each argument that would normally be separated by a space in a bash command should be in their own quotes",
                "code":
                {   
                    "code":"# syntax=docker/dockerfile:1\nFROM python:3.8-slim-buster\n\nWORKDIR /app\n\nCOPY requirements.txt requirements.txt\nRUN pip3 install -r requirements.txt\n\nCOPY . .\n\nCMD [\"python3\", \"-m\" , \"flask\", \"run\", \"--host=0.0.0.0\"]",
                    "language":"docker"
                }
            },
            {
                "title":"Building and running the container",
                "text": "Simply run this command with whatever tag you want to use, then run the run command to start the container. Running this container won't publish any ports or anything but it should allow you to test to see if the container at least starts up. Additional arguments can be supplied, or you can use docker-compose to make it nice and tidy",
                "code":
                {   
                    "code":"docker build --tag python-docker .\ndocker run python-docker",
                    "language":"bash"
                }
            },
            {
                "title":"Setting Up Github Actions for CI",
                "text": "You will want to create a workflow file like this, making sure to change the DOCKER_IMAGE_NAME, and set the DOCKER_HUB_USERNAME and DOCKER_HUB_ACCESS_TOKEN in your github secrets",
                "code":
                {   
                    "code":"name: build_and_publish_container\n \non:\n  push:\n    branches: [ \"master\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v3\n      -\n        name: Login to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKER_HUB_USERNAME }}\n          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}\n      -\n        name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      -\n        name: Build and push\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          file: ./Dockerfile\n          push: true\n          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/DOCKER_IMAGE_NAME:latest",
                    "language":"yaml"
                }
            }
        ]
    },
    {
        "id":"1",
        "title": "Setting Up Traefik to serve as a reverse proxy",
        "sections": 
        [
            {
                "title": "Introduction",
                "text": "A reverse proxy is important as it allows you to automatically manage secure connections to apps. Traefik makes a great choice for a reverse proxy as integrates well with docker and can automatically pick up new containers and these containers provide their own rules. This allows you to set up traefik once and then never touch it again as all of the routing rules are set in the labels of containers"
            }
        ]
    }
]
